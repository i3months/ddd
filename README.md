# ITDDD

"도메인 주도 설계 철저 입문 : 코드와 패턴으로 밑바닥부터 이해하는 DDD"의 14장 예제 코드입니다.
1장부터 13장에 실린 예제 코드도 보실 수 있습니다.

# 각 디렉토리의 내용

## Layered

https://github.com/wikibook/ddd/tree/master/Layered

계층형 아키텍처를 준수해 구성한 코드입니다.
프레젠테이션 계층, 도메인 계층, 애플리케이션 계층, 인프라스트럭쳐 계층이 별도의 프로젝트로 구성돼 있습니다.

## Layered_UsingInternal

https://github.com/wikibook/ddd/tree/master/Layered_UsingInternal

계층형 아키텍처를 준수해 구성한 코드입니다.
internal 접근제어자를 활용해 메서드에 대한 접근을 통제하여 의도하지 않은 메서드 호출을 차단한 것이
Layerd 디렉토리의 코드와 차이점입니다.

## CleanLike

https://github.com/wikibook/ddd/tree/master/CleanLike

클린 아키텍처를 준수해 구성한 코드입니다.
모든 유스케이스가 별도의 클래스로 구현되었으므로 코드의 결합이 느슨하게 구현돼 있습니다.

## SampleCodes

14장을 제외한 나머지 장에 실린 예제 코드입니다.


# 정리 


## 도입

소프트웨어의 목적은 도메인에서 이용자들이 직면한 문제를 해결하는 것 
이용자들의 문제를 정확하게 이해해야 소프트웨어를 개발할 수 있다. 
개발 기법, 최신 기술 등 기술적 접근법으로만 문제를 해결할 수는 없다.

모델은 현실의 사건, 개념을 추상화한 것 
소설가에게 펜은 글쓰는 도구, 사업가에게 펜은 돈버는도구 
개념 추상화 작업을 모델링이라고 함 
도메인 전분가와 소프트웨어 전문가가 협업해 도메인 모델을 만들어야 함

## 기본개념 

VO
불변성 덕분에 동시성, 사이드이펙트 관련 문제를 가지지 않는다. 
VO간 비교 시에도 요소 하나씩 꺼내쓰기보다는 equals 오버라이드 
장점은 표현력 증가 / 무결성유지 / 잘못된 대입 방지 / 로직 중앙집중화 

엔티티
db의 엔티티 - 현실세계에서 구별할수있는 데이터의 집합으로 테이블로 표현됨 

JPA의 엔티티 - 테이블을 객체지향적으로 표현한것. 테이블과 매핑돼 레코드를 객체의 인스턴스로 다룰 수 있음. 

DDD의 엔티티 - 도메인 모델 내에서 식별할 수 있는 개체를 의미함 
단순한 데이터 집합이 아니라 식별자로 구분되는 도메인 내 핵심개념을 의미. 도메인 모델을 구현한 도메인 객체 

DDD에서의 엔티티와 VO가 다른 점은 동일성 식별이 가능한지에 있음 
엔티티는 가변이고 속성이 같아도 구분할 수 있고 동일성으로 구분됨. 식별자를 사용 

도메인 객체를 사용하면 자기 서술적인 코드가 돼 문서 없이도 코드를 이해할 수 있음

ddd에서 서비스는 두가지로 구분됨. 도메인을 위한 서비스 / 애플리케이션을 위한 서비스 

도메인 서비스 - 도메인 객체에 정의하기 어색한 행동을 정의함 
도메인 객체는 행동을 가질 수 있으니 부자연스러운 행동만 서비스에 정의해야 함 
로직이 흩어지면 변화에 대응하기 힘드니 중복 제거를 항상 고려할 것 

Student . StudentService 이런식으로 사용하는데.. 
스프링부트로 개발할 때 DDD 를 어느정도 적용하고 있었음

애플리케이션 서비스 - 유스케이스를 구현하는 객체를 의미 
유스케이스는 각 기능을 생각하면 됨 회원가입 탈퇴 조회..
애플리케이션의 비즈니스 로직을 구현하지 않고 사용자의 요청을 도메인 모델 또는 서비스에 전달하고 결과를 받아 사용자에게 반환함 

도메인 로직과 애플리케이션 로직을 분리해 복잡성을 관리 

애플리케이션 서비스가 도메인 객체를 직접 클라이언트에게 노출하는 경우 의존성이 생기고 비즈니스로직이 분산돼 좋지 않음. 
따라서 DTO를 도입해서 사용함 

클라이언트와 데이터를 교환할 때 DTO를 사용함. 도메인 로직을 포함하지 않는 구조체 
값만 가지고 비즈니스 로직을 포함하지 않는 레이어 간 데이터 전송을 위한 객체임 

도메인 객체를 외부에 공개하냐 마냐는 큰 분기점
프로젝트의 정책을 따르는 편이 합리적이지만.. 노출하지 않는 편이 좋다고 함 

애플리케이션 서비스에 도메인 규칙을 기술하는건 좋지 않음 도메인 서비스와 중복되니까 
그러니 도메인 서비스에 작성한 로직을 가져와서 사용하자 

애플리케이션의 응집도를 높이려면 그냥 ApplicationService 말고 DeleteService JoinService 같이 서비스를 여러 단위로 나누는것도 방법임 
책임을 분명하게 나눈다면 클래스를 분리하는게 당연함. 
애초에 사용자라는 개념으로만 묶여있었으니 목적과 처리 내용은 다를 수 있으니 분리 
같은 패키지에 위치하면 찾기도 쉬울거고.. 
근데 꼭 이러라는건 아니고 응집도 차원에서 생각하면 이런 방법도 가능하다는거임 

서비스에서도 인터페이스를 도입하면 분업 시 유용함

인터페이스 도입하고 생성자주입으로 IoC 수행 
스프링에서는 빈으로 등록해 Autowired로 자동 주입하지만 

C#같은 빈 개념 안쓰는 기술도 생성자주입은 사용함 
ASP .NET에서는 빈개념은 안쓰지만 따로 설정클래스를 두고 싱글톤 직접 사용함 
@GetMapping 같은 애너테이션도 [] attribute로 제공 

팩토리 패턴은 
ddd에서 복잡한객체의 생성 로직을 캡슐화하는 역할을 수행함 
객체 생성이 단순하지 않거나 특정 규칙을 만족시켜야 하는 경우 팩토리 패턴을 도입 
객체 생성을 추상화하고 클라이언트 코드를 객체 생성의 복잡성으로부터 분리하는게 목적 
원래는 생성자로 객체를 생성하는거지만 팩토리 패턴을 도입해 클라이언트를 간소화 
객체의 생성 로직을 클라이언트로부터 숨길 수 있음